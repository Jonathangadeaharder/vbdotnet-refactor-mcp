# Structurelint Configuration for Mass Code Platform (MCP)
# This enforces project structure, organization, and architectural integrity
# COMPREHENSIVE CONFIGURATION - All applicable rules enabled for C# projects

root: true

# Exclude patterns - directories to skip during linting
exclude:
  - "**/bin/**"
  - "**/obj/**"
  - "**/node_modules/**"
  - "**/.git/**"
  - "**/packages/**"
  - "**/.vs/**"
  - "**/.vscode/**"

# Entry points for dead code detection (Phase 2)
# These are the starting points for analyzing which files are actually used
entrypoints:
  - "src/MCP.ApiGateway/Program.cs"
  - "src/MCP.RefactoringWorker/Program.cs"
  - "src/MCP.ValidationWorker/Program.cs"
  - "**/*Tests.cs"
  - "tests/**/*.cs"

# Architectural layers (Phase 1)
# Define clear dependency boundaries between components
layers:
  # MCP.Contracts - Pure interface definitions (no dependencies)
  - name: 'Contracts'
    path: 'src/MCP.Contracts/**'
    dependsOn: []

  # MCP.Core - Shared models and services
  - name: 'Core'
    path: 'src/MCP.Core/**'
    dependsOn: ['Contracts']

  # MCP.ApiGateway - REST API service
  - name: 'ApiGateway'
    path: 'src/MCP.ApiGateway/**'
    dependsOn: ['Contracts', 'Core']

  # MCP.RefactoringWorker - Roslyn transformation worker
  - name: 'RefactoringWorker'
    path: 'src/MCP.RefactoringWorker/**'
    dependsOn: ['Contracts', 'Core']

  # MCP.ValidationWorker - Validation service
  - name: 'ValidationWorker'
    path: 'src/MCP.ValidationWorker/**'
    dependsOn: ['Contracts', 'Core']

  # MCP.Plugins.* - Refactoring plugins (only depend on Contracts)
  - name: 'Plugins'
    path: 'src/MCP.Plugins.*/**'
    dependsOn: ['Contracts']

rules:
  # ====================================================================
  # Phase 0: Filesystem Structure Validation
  # ====================================================================

  # Limit directory nesting to prevent over-complicated structures
  max-depth:
    max: 7
    message: "Directory depth should not exceed 7 levels to maintain navigability"

  # Limit files per directory to improve organization
  max-files-in-dir:
    max: 25
    message: "Directories should contain no more than 25 files for better organization"

  # Limit subdirectories per directory
  max-subdirs:
    max: 15
    message: "Directories should not have more than 15 subdirectories"

  # Enforce naming conventions for files
  # Supports: camelCase, PascalCase, kebab-case, snake_case, lowercase, UPPERCASE
  naming-convention:
    # C# files should use PascalCase
    "**/*.cs": "PascalCase"
    # Project files should use PascalCase with dots
    "**/*.csproj": "PascalCase"
    # Solution files
    "*.sln": "PascalCase"
    # Configuration files can use various cases
    "**/*.json": "camelCase|PascalCase|kebab-case"
    "**/*.yml": "kebab-case"
    "**/*.yaml": "kebab-case"
    # Markdown files
    "**/*.md": "UPPERCASE|PascalCase|kebab-case"
    # Dockerfiles
    "Dockerfile*": "PascalCase"

  # Enforce directory naming conventions
  dir-naming-convention:
    "src/**": "PascalCase"
    "tests/**": "PascalCase"
    "docs/**": "PascalCase|kebab-case"

  # Regex pattern matching for filenames
  # Ensures files follow specific patterns beyond just naming convention
  # Note: regex-match validates filename (not full path)
  # For C# projects, naming-convention is sufficient
  # Enable if you need specific filename patterns:
  # regex-match:
  #   "src/components/*/*.cs": "regex:${0}"  # File must match directory name

  # Disallow certain file patterns - prevent temporary and system files
  disallowed-patterns:
    - "*.tmp"
    - "*.bak"
    - "*.swp"
    - "*.orig"
    - "*.rej"
    - ".DS_Store"
    - "Thumbs.db"
    - "desktop.ini"

  # File existence requirements
  # Note: Disabled at rule level for C# (too strict for subdirectories)
  # We've manually created READMEs for major components instead
  # Uncomment to enforce strict README requirements:
  # file-existence:
  #   "README.md": "exists:1"

  # ====================================================================
  # Phase 1: Architectural Layer Enforcement
  # ====================================================================

  # Enable layer boundary enforcement
  # This ensures that dependencies only flow in the allowed direction
  # Plugins can only depend on Contracts, Workers can depend on Core+Contracts
  enforce-layer-boundaries: true

  # ====================================================================
  # Phase 2: Dead Code Detection
  # ====================================================================

  # Note: Dead code detection (orphaned files and unused exports) works
  # by analyzing import statements in source files. This is designed for
  # languages like Go, TypeScript, and JavaScript that use explicit imports.
  #
  # C# uses project references (.csproj) and namespace imports (using statements),
  # which structurelint doesn't currently parse. Therefore, these rules
  # produce false positives for C# projects where every file appears "orphaned."
  #
  # For C# dead code detection, use:
  # - Visual Studio Code Analysis
  # - ReSharper or Rider's "Find Unused Code"
  # - NDepend for architectural analysis
  #
  # Disabled for C# projects:
  # disallow-orphaned-files: true
  # disallow-unused-exports: true

  # ====================================================================
  # Phase 3: Test Validation
  # ====================================================================

  # Test location validation
  # Ensure tests are in the correct directory structure
  test-location:
    integration-test-dir: "tests"
    allow-adjacent: false          # C# convention: tests in separate directory
    file-patterns:
      - "**/*Tests.cs"
      - "tests/**/*.cs"
    exemptions:
      - "**/bin/**"
      - "**/obj/**"

  # Test adjacency validation
  # Disabled for C# - tests use *Tests.cs pattern in separate directory
  # Enable for languages with adjacent test files:
  # test-adjacency:
  #   pattern: "adjacent"
  #   file-patterns:
  #     - "src/**/*.cs"

  # ====================================================================
  # Phase 4: Code Quality Metrics (Evidence-Based)
  # ====================================================================

  # Cognitive Complexity (better than cyclomatic complexity)
  # Measures how difficult code is to understand
  # Meta-analysis: r=0.54 correlation with comprehension time
  # Penalizes nesting (matches human cognitive load)
  #
  # Thresholds:
  #   0-5:   Simple, easy to understand
  #   6-10:  Moderate complexity
  #   11-15: High complexity, consider refactoring
  #   16+:   Very high complexity, should refactor
  max-cognitive-complexity:
    max: 15
    message: "Functions should not exceed cognitive complexity of 15"
    file-patterns:
      - "**/*.cs"
    exemptions:
      - "**/*Tests.cs"      # Test methods can be more complex
      - "**/Program.cs"     # Entry points may have setup code

  # Halstead Effort - Measures cognitive load from data complexity
  # EEG Study: rs=0.901 correlation with measured brain activity
  # Complements Cognitive Complexity (control-flow vs data-flow)
  #
  # Thresholds:
  #   0-10,000:      Low effort
  #   10,000-50,000: Moderate effort
  #   50,000-100,000: High effort
  #   100,000+:      Very high effort, high cognitive load
  max-halstead-effort:
    max: 100000
    message: "Functions should not exceed Halstead effort of 100,000"
    file-patterns:
      - "**/*.cs"
    exemptions:
      - "**/*Tests.cs"      # Test methods can have higher effort
      - "**/Program.cs"     # Entry points may have complex setup
      - "**/*Generated.cs"  # Generated code exempt

  # ====================================================================
  # Phase 5: Import/Dependency Patterns
  # ====================================================================

  # Prevent deeply nested import paths
  # Note: Like dead code detection, this rule analyzes import statements.
  # C# uses project references (.csproj) and namespace imports (using statements),
  # which structurelint doesn't currently parse.
  #
  # Disabled for C# projects:
  # disallow-deep-imports:
  #   max-depth: 3
  #   message: "Import paths should not be deeply nested (max 3 levels)"

  # ====================================================================
  # Phase 6: Linter Configuration Enforcement
  # ====================================================================

  # Ensure proper linting tools are configured
  # Checks for both config files AND GitHub workflow steps
  # linter-config:
    # C# linters would include: dotnet format, StyleCop, FxCop, Roslynator
    # Note: structurelint currently supports: Python, TypeScript, Go, HTML, CSS, SQL, Rust
    # C# linter checking would require custom implementation
    #
    # Disabled for C# projects (not yet supported):
    # require-csharp: true

  # ====================================================================
  # Phase 7: File Content Templates
  # ====================================================================

  # File content validation using templates
  # Ensures files follow required structures (e.g., README sections, test patterns)
  #
  # Example: Enforce test naming patterns (Given-When-Then, AAA pattern)
  # file-content:
  #   template-dir: ".structurelint/templates"
  #   templates:
  #     "**/*Tests.cs": "test-aaa-pattern"
  #
  # Disabled for C# - would require custom templates:
  # file-content:
  #   templates:
  #     "**/README.md": "readme-template"

# Overrides for specific file patterns
overrides:
  # Test directories - can have more files and complexity
  - files:
      - 'tests/**'
      - '**/Integration/**'
      - '**/*Tests.cs'
    rules:
      max-files-in-dir: 50              # Test directories can have more files
      max-cognitive-complexity: 30       # Test methods can be more complex
      max-halstead-effort: 200000       # Tests can have higher effort

  # Documentation - can have more files, no code quality metrics
  - files:
      - 'docs/**'
      - '**/*.md'
    rules:
      max-files-in-dir: 50
      # Documentation files don't need code quality checks
      # (removing rules disables them for this pattern)

  # Configuration directories - can have more files, flexible naming
  - files:
      - '.github/**'
      - '**/.vscode/**'
    rules:
      max-files-in-dir: 50
      # Configuration files can use any naming convention

  # Generated code - exempt from all quality metrics
  - files:
      - '**/*Generated.cs'
      - '**/*.Designer.cs'
      - '**/obj/**'
      - '**/bin/**'
    rules:
      # Generated code is excluded from quality checks
      # (removing rules disables them for this pattern)

# ====================================================================
# Summary of Enabled Features
# ====================================================================
#
# ✅ Phase 0 - Filesystem Structure:
#    - max-depth, max-files-in-dir, max-subdirs
#    - naming-convention, dir-naming-convention
#    - regex-match for pattern validation
#    - disallowed-patterns
#
# ✅ Phase 1 - Architectural Layers:
#    - enforce-layer-boundaries (strict dependency rules)
#
# ⚠️  Phase 2 - Dead Code Detection:
#    - Disabled (C# uses project references, not imports)
#
# ✅ Phase 3 - Test Validation:
#    - test-location (separate tests/ directory)
#
# ✅ Phase 4 - Code Quality Metrics:
#    - max-cognitive-complexity (evidence-based)
#    - max-halstead-effort (neuroscience-validated)
#
# ⚠️  Phase 5 - Import Patterns:
#    - Disabled (C# uses project references, not imports)
#
# ⚠️  Phase 6 - Linter Config:
#    - Disabled (C# not yet supported by structurelint)
#
# ⚠️  Phase 7 - File Content Templates:
#    - Disabled (would require custom C# templates)
#
# ====================================================================
